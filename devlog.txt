5/6/2024
- added media archive mount to virtual filesystem
- refactored for cleanliness

5/5/2024
- added init/deinit code for virtual filesystem (via physfs)
- confirmed build on macOS; still need to validate packaging and signing as an app bundle in Xcode
- reviewed window scaling approaches; need virtual fs in place before
- this can be implemented

5/2/2024
- set the build type to C++ 20 to build in Visual Studio
- added a console logger; you can set a preprocessor directive to disable debug logs (NDEBUG)
- added basic window functions

4/30/2024
librge is short for lib retro game engine.
librge is intended to make retro game programming fun.

What would we want from a library to make retro game programming fun?
Here is my stream of consciousness:
- the library should support professional-grade projects:
    - easy to build, test, learn, and use
    - the code should be clean, documented, and tested
    - there should be professional-grade examples (a finished, non-trivial game)

- developers should get to focus on coding fun business logic, not boring systems code
- developers should be able to use this library from any programming language they want
- the library should offer constructs that bridge the gap between game library and a game engine:
    - examples of fully packaged ready-to-ship binaries and media files
    - game windows should support logical scaling for low-res games
    - virtual file system
    - abstractions for input devices:
        input.shoot == keyboard.press && gamepad.press && mouse.press
    - graceful handling of multiple hardware devices (monitors, gamepads, etc.)
    - can we let users pick their coordinate system?

Backlog: Build improvements:
- Add options for release and debug builds

```
cmake .. -DCMAKE_BUILD_TYPE=Release  # Or Debug
```
- Setup automated test, build, deploy workflow
- Deploy targets: Windows, macOS, Linux, Web
- Add sanitizer builds

Backlog: Engine work:
1. [+] Setup console logging (debug, info, error, warning)
2. Implement systems handler
3. Implement virtual file system
4. Implement windowing, scaling, and drawing
5. Implement delta time and frame rates
6. Implement sound and music
7. Implement true type font renderer
8. Implement input handlers (keyboard, mouse, gamepad)
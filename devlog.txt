7/6/2024
- Added basic music functions
- need to add UI text; should be ready for a tiled map parser after

7/5/2024
- delta time was causing jitter, so I removed it. The solution works as long as the host computer hits the target frame rate
- added a simple collision rect checker
- Audio will take a little more work due to memory management
    - need to encapsulate sound and music in a class and use smart pointers

7/4/2024
- Added a mock player with working camera scrolling
- Added a GetDeltaTime() function
- TODO: animation, sound, music, text, collisions
- Happy 4th of July

7/2/2024
- Added some basic keyboard functions
- They are just a wrapper around raylib's keyboard functions
- Keyboard functions prove camera scrolling works correctly in the simple case
- Next I need to add a mock character, and prove the camera can center on it as the character moves around the map
- After that we'll need collisions, sound, music, and text/UI functions
- That should be enough to make a simple pong game
- The pong game should drive the high-level C++ API

7/1/2024
- Added some camera functions
- Need to add some basic keyboard input to test camera movement

6/24/2024
- added clang-format with vim hotkey
- minor refactor

6/23/2024
- I was testing out the codebase using my new vimrc configuration. The language server was not correctly interpreting my include paths. I learned that you can use cmake to create a file, 'compile_commands.json', which lists the specific commands needed to compile the program. The language server seems to identify and read this file, and as a result, it now correctly interprets my include paths.
- Next task: setup smooth scrolling

6/13/2024
- fixed Linux build failures by enabling position independent code compiler flag

5/26/2024
- added proper window scaling


5/12/2024
- added basic texture rendering
- spent a while troubleshooting a failed PHYSFS file load
- it was caused by an invalid filepath; we provided "media/images/foo.png" but "images/foo.png" was expected
- need to start working on proper window resizing and scaling next

5/6/2024
- added media archive mount to virtual filesystem
- refactored for cleanliness

5/5/2024
- added init/deinit code for virtual filesystem (via physfs)
- confirmed build on macOS; still need to validate packaging and signing as an app bundle in Xcode
- reviewed window scaling approaches; need virtual fs in place before
- this can be implemented

5/2/2024
- set the build type to C++ 20 to build in Visual Studio
- added a console logger; you can set a preprocessor directive to disable debug logs (NDEBUG)
- added basic window functions

4/30/2024
librge is short for lib retro game engine.
librge is intended to make retro game programming fun.

What would we want from a library to make retro game programming fun?
Here is my stream of consciousness:
- the library should support professional-grade projects:
    - easy to build, test, learn, and use
    - the code should be clean, documented, and tested
    - there should be professional-grade examples (a finished, non-trivial game)

- developers should get to focus on coding fun business logic, not boring systems code
- developers should be able to use this library from any programming language they want
- the library should offer constructs that bridge the gap between game library and a game engine:
    - examples of fully packaged ready-to-ship binaries and media files
    - game windows should support logical scaling for low-res games
    - virtual file system
    - abstractions for input devices:
        input.shoot == keyboard.press && gamepad.press && mouse.press
    - graceful handling of multiple hardware devices (monitors, gamepads, etc.)
    - can we let users pick their coordinate system?

Backlog: Build improvements:
- Add options for release and debug builds

```
cmake .. -DCMAKE_BUILD_TYPE=Release  # Or Debug
```
- Setup automated test, build, deploy workflow
- Deploy targets: Windows, macOS, Linux, Web
- Add sanitizer builds

Backlog: Engine work:
1. [+] Setup console logging (debug, info, error, warning)
2. Implement systems handler
3. Implement virtual file system
4. Implement windowing, scaling, and drawing
5. Implement delta time and frame rates
6. Implement sound and music
7. Implement true type font renderer
8. Implement input handlers (keyboard, mouse, gamepad)
